关于答案：每种状态由另一种状态转换得到，格式为 hash编号： 另一状态的hash编号 + 门的类型
门的类型：
1: Tof(1,a)
2: Tof(1,b)
3: Tof(1,c)
4: Tof(b,a)
5: Tof(c,a)
6: Tof(a,b)
7: Tof(c,b)
8: Tof(a,c)
9: Tof(b,c)
10: Tof(cb,a)
11: Tof(ca,b)
12: Tof(ba,c)

1.本程序采用深度优先搜索+迭代加深算法来保证找到最优解
2.数据存储方式为整数，采用c++自带二进制位运算
		i = i >> n		i在二进制位下右移n位
		i = i & (1 << n)		将i在二进制位下第n位取反
		(i >> n) & 1		取i在二进制位下的第n位
3.每种状态可以由其他状态得来，于是先求解门数较小的状态，再来求解复杂的状态。
4.将每种状态hash，并记录是否已求得解。若其他状态搜索时变化为已求解状态则可以实现门的叠加求得最优答案
（每种状态都是由另外门数小1的状态变化而来！所以最优解为n+1的状态一定能由最优解n的状态进行一次变化求得）
//（对于叠加求解的门不能保证其最优性,若状态f[x]经过转化，第一次成为已求解的f[y],并不说明叠加的答案最优，因为f[x]可能经过稍多的变化成为f[z],而f[z]比f[y]到[0,1,2,3,4,5,6,7]的步数小得多，则此时与f[y]答案叠加明显不为最优解。）//
5.存储未求解的状态用了循环队列。


Ps：
//1.启发式搜索应该为解决此类问题的最优秀的算法，但此问题可以用本算法解决。
1.本算法极优
2.hash的方法本程序采用将其化为8进制数，有更加优秀的全排列hash方法，由于实现复杂，所以用8进制发代替。
//3.另外的想法是可以双向搜索，由初态和末态各进行搜索并记录，搜索复杂度将大大减小，作为优化的方法在此处记录。(本算法极优)

个人的一点看法：
R-M算法的最终方程组的化简应该等价于真值表求解的方法，其化简方式与真值表的答案一一对应，即2个问题可以互相转化。那么R-M算法在编程上不如真值表方法直接，且问题没有得到简化，在编程上没有得到解决，不如舍弃（R-M算法在人工求解的时候大大简化了问题，但在编程求解时并未简化问题）

“//”后面代表构思程序时一些不全面或错误的想法!!（仅记录思考的痕迹）
